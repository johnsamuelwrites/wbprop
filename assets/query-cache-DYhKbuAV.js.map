{"version":3,"file":"query-cache-DYhKbuAV.js","sources":["../../src/services/cache/query-cache.ts"],"sourcesContent":["import type { SparqlResults } from '@/types'\n\nexport interface CacheEntry {\n  data: SparqlResults\n  timestamp: number\n  instanceId: string\n}\n\nexport interface CacheOptions {\n  ttl?: number // milliseconds, default 5 minutes\n  maxEntries?: number\n  storageKey?: string\n}\n\nconst DEFAULT_TTL = 5 * 60 * 1000 // 5 minutes\nconst DEFAULT_MAX_ENTRIES = 100\nconst DEFAULT_STORAGE_KEY = 'wbprop-query-cache'\n\n/**\n * Query result cache with localStorage persistence and TTL-based invalidation\n */\nexport class QueryCache {\n  private memoryCache = new Map<string, CacheEntry>()\n  private ttl: number\n  private maxEntries: number\n  private storageKey: string\n\n  constructor(options: CacheOptions = {}) {\n    this.ttl = options.ttl ?? DEFAULT_TTL\n    this.maxEntries = options.maxEntries ?? DEFAULT_MAX_ENTRIES\n    this.storageKey = options.storageKey ?? DEFAULT_STORAGE_KEY\n    this.loadFromStorage()\n  }\n\n  /**\n   * Generate a cache key from instance ID and SPARQL query\n   */\n  static makeKey(instanceId: string, query: string): string {\n    // Normalize whitespace for consistent keys\n    const normalized = query.replace(/\\s+/g, ' ').trim()\n    return `${instanceId}:${normalized}`\n  }\n\n  /**\n   * Get a cached result if it exists and hasn't expired\n   */\n  get(key: string): SparqlResults | null {\n    const entry = this.memoryCache.get(key)\n    if (!entry) return null\n\n    if (this.isExpired(entry)) {\n      this.memoryCache.delete(key)\n      this.saveToStorage()\n      return null\n    }\n\n    return entry.data\n  }\n\n  /**\n   * Store a query result in the cache\n   */\n  set(key: string, data: SparqlResults, instanceId: string): void {\n    // Evict oldest entries if at capacity\n    if (this.memoryCache.size >= this.maxEntries) {\n      this.evictOldest()\n    }\n\n    this.memoryCache.set(key, {\n      data,\n      timestamp: Date.now(),\n      instanceId,\n    })\n\n    this.saveToStorage()\n  }\n\n  /**\n   * Remove all entries for a specific instance\n   */\n  invalidateInstance(instanceId: string): void {\n    for (const [key, entry] of this.memoryCache) {\n      if (entry.instanceId === instanceId) {\n        this.memoryCache.delete(key)\n      }\n    }\n    this.saveToStorage()\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    this.memoryCache.clear()\n    try {\n      localStorage.removeItem(this.storageKey)\n    } catch {\n      // localStorage not available\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): { entries: number; maxEntries: number; ttlMs: number } {\n    return {\n      entries: this.memoryCache.size,\n      maxEntries: this.maxEntries,\n      ttlMs: this.ttl,\n    }\n  }\n\n  private isExpired(entry: CacheEntry): boolean {\n    return Date.now() - entry.timestamp > this.ttl\n  }\n\n  private evictOldest(): void {\n    let oldestKey: string | null = null\n    let oldestTime = Infinity\n\n    for (const [key, entry] of this.memoryCache) {\n      if (entry.timestamp < oldestTime) {\n        oldestTime = entry.timestamp\n        oldestKey = key\n      }\n    }\n\n    if (oldestKey) {\n      this.memoryCache.delete(oldestKey)\n    }\n  }\n\n  private loadFromStorage(): void {\n    try {\n      const raw = localStorage.getItem(this.storageKey)\n      if (!raw) return\n\n      const entries: Array<[string, CacheEntry]> = JSON.parse(raw)\n      const now = Date.now()\n\n      for (const [key, entry] of entries) {\n        // Only load non-expired entries\n        if (now - entry.timestamp <= this.ttl) {\n          this.memoryCache.set(key, entry)\n        }\n      }\n    } catch {\n      // Corrupted cache or localStorage unavailable - start fresh\n      this.clear()\n    }\n  }\n\n  private saveToStorage(): void {\n    try {\n      const entries = Array.from(this.memoryCache.entries())\n      localStorage.setItem(this.storageKey, JSON.stringify(entries))\n    } catch {\n      // localStorage full or unavailable - memory cache still works\n    }\n  }\n}\n\n// Singleton instance for the app\nlet globalCache: QueryCache | null = null\n\nexport function getQueryCache(): QueryCache {\n  if (!globalCache) {\n    globalCache = new QueryCache()\n  }\n  return globalCache\n}\n"],"names":["DEFAULT_STORAGE_KEY","QueryCache","options","instanceId","query","normalized","key","entry","data","oldestKey","oldestTime","raw","entries","now","globalCache","getQueryCache"],"mappings":"AAgBA,MAAMA,EAAsB,qBAKrB,MAAMC,CAAW,CACd,gBAAkB,IAClB,IACA,WACA,WAER,YAAYC,EAAwB,GAAI,CACtC,KAAK,IAAMA,EAAQ,KAAO,IAC1B,KAAK,WAAaA,EAAQ,YAAc,IACxC,KAAK,WAAaA,EAAQ,YAAcF,EACxC,KAAK,gBAAA,CACP,CAKA,OAAO,QAAQG,EAAoBC,EAAuB,CAExD,MAAMC,EAAaD,EAAM,QAAQ,OAAQ,GAAG,EAAE,KAAA,EAC9C,MAAO,GAAGD,CAAU,IAAIE,CAAU,EACpC,CAKA,IAAIC,EAAmC,CACrC,MAAMC,EAAQ,KAAK,YAAY,IAAID,CAAG,EACtC,OAAKC,EAED,KAAK,UAAUA,CAAK,GACtB,KAAK,YAAY,OAAOD,CAAG,EAC3B,KAAK,cAAA,EACE,MAGFC,EAAM,KARM,IASrB,CAKA,IAAID,EAAaE,EAAqBL,EAA0B,CAE1D,KAAK,YAAY,MAAQ,KAAK,YAChC,KAAK,YAAA,EAGP,KAAK,YAAY,IAAIG,EAAK,CACxB,KAAAE,EACA,UAAW,KAAK,IAAA,EAChB,WAAAL,CAAA,CACD,EAED,KAAK,cAAA,CACP,CAKA,mBAAmBA,EAA0B,CAC3C,SAAW,CAACG,EAAKC,CAAK,IAAK,KAAK,YAC1BA,EAAM,aAAeJ,GACvB,KAAK,YAAY,OAAOG,CAAG,EAG/B,KAAK,cAAA,CACP,CAKA,OAAc,CACZ,KAAK,YAAY,MAAA,EACjB,GAAI,CACF,aAAa,WAAW,KAAK,UAAU,CACzC,MAAQ,CAER,CACF,CAKA,UAAmE,CACjE,MAAO,CACL,QAAS,KAAK,YAAY,KAC1B,WAAY,KAAK,WACjB,MAAO,KAAK,GAAA,CAEhB,CAEQ,UAAUC,EAA4B,CAC5C,OAAO,KAAK,IAAA,EAAQA,EAAM,UAAY,KAAK,GAC7C,CAEQ,aAAoB,CAC1B,IAAIE,EAA2B,KAC3BC,EAAa,IAEjB,SAAW,CAACJ,EAAKC,CAAK,IAAK,KAAK,YAC1BA,EAAM,UAAYG,IACpBA,EAAaH,EAAM,UACnBE,EAAYH,GAIZG,GACF,KAAK,YAAY,OAAOA,CAAS,CAErC,CAEQ,iBAAwB,CAC9B,GAAI,CACF,MAAME,EAAM,aAAa,QAAQ,KAAK,UAAU,EAChD,GAAI,CAACA,EAAK,OAEV,MAAMC,EAAuC,KAAK,MAAMD,CAAG,EACrDE,EAAM,KAAK,IAAA,EAEjB,SAAW,CAACP,EAAKC,CAAK,IAAKK,EAErBC,EAAMN,EAAM,WAAa,KAAK,KAChC,KAAK,YAAY,IAAID,EAAKC,CAAK,CAGrC,MAAQ,CAEN,KAAK,MAAA,CACP,CACF,CAEQ,eAAsB,CAC5B,GAAI,CACF,MAAMK,EAAU,MAAM,KAAK,KAAK,YAAY,SAAS,EACrD,aAAa,QAAQ,KAAK,WAAY,KAAK,UAAUA,CAAO,CAAC,CAC/D,MAAQ,CAER,CACF,CACF,CAGA,IAAIE,EAAiC,KAE9B,SAASC,GAA4B,CAC1C,OAAKD,IACHA,EAAc,IAAIb,GAEba,CACT"}